{"ast":null,"code":"var R = {\n    0: 8203,\n    1: 8204,\n    2: 8205,\n    3: 8290,\n    4: 8291,\n    5: 8288,\n    6: 65279,\n    7: 8289,\n    8: 119155,\n    9: 119156,\n    a: 119157,\n    b: 119158,\n    c: 119159,\n    d: 119160,\n    e: 119161,\n    f: 119162\n  },\n  b = {\n    0: 8203,\n    1: 8204,\n    2: 8205,\n    3: 65279\n  },\n  V = new Array(4).fill(String.fromCodePoint(b[0])).join(\"\"),\n  J = \"\\0\";\nfunction _(e) {\n  let t = JSON.stringify(e);\n  return `${V}${Array.from(t).map(o => {\n    let n = o.charCodeAt(0);\n    if (n > 255) throw new Error(`Only ASCII edit info can be encoded. Error attempting to encode ${t} on character ${o} (${n})`);\n    return Array.from(n.toString(4).padStart(4, \"0\")).map(r => String.fromCodePoint(b[r])).join(\"\");\n  }).join(\"\")}`;\n}\nfunction D(e) {\n  return !Number.isNaN(Number(e)) || /[a-z]/i.test(e) && !/\\d+(?:[-:\\/]\\d+){2}(?:T\\d+(?:[-:\\/]\\d+){1,2}(\\.\\d+)?Z?)?/.test(e) ? !1 : !!Date.parse(e);\n}\nfunction Q(e) {\n  try {\n    new URL(e, e.startsWith(\"/\") ? \"https://acme.com\" : void 0);\n  } catch (t) {\n    return !1;\n  }\n  return !0;\n}\nfunction z(e, t, o = \"auto\") {\n  return o === !0 || o === \"auto\" && (D(e) || Q(e)) ? e : `${e}${_(t)}`;\n}\nvar Z = Object.fromEntries(Object.entries(b).map(e => e.reverse())),\n  k = Object.fromEntries(Object.entries(R).map(e => e.reverse())),\n  G = `${Object.values(R).map(e => `\\\\u{${e.toString(16)}}`).join(\"\")}`,\n  I = new RegExp(`[${G}]{4,}`, \"gu\");\nfunction H(e) {\n  let t = e.match(I);\n  if (t) return K(t[0], !0)[0];\n}\nfunction K(e, t = !1) {\n  let o = Array.from(e);\n  if (o.length % 2 === 0) {\n    if (o.length % 4 || !e.startsWith(V)) return X(o, t);\n  } else throw new Error(\"Encoded data has invalid length\");\n  let n = [];\n  for (let r = o.length * 0.25; r--;) {\n    let s = o.slice(r * 4, r * 4 + 4).map(i => Z[i.codePointAt(0)]).join(\"\");\n    n.unshift(String.fromCharCode(parseInt(s, 4)));\n  }\n  if (t) {\n    n.shift();\n    let r = n.indexOf(J);\n    return r === -1 && (r = n.length), [JSON.parse(n.slice(0, r).join(\"\"))];\n  }\n  return n.join(\"\").split(J).filter(Boolean).map(r => JSON.parse(r));\n}\nfunction X(e, t) {\n  var o;\n  let n = [];\n  for (let c = e.length * 0.5; c--;) {\n    let u = `${k[e[c * 2].codePointAt(0)]}${k[e[c * 2 + 1].codePointAt(0)]}`;\n    n.unshift(String.fromCharCode(parseInt(u, 16)));\n  }\n  let r = [],\n    s = [n.join(\"\")],\n    i = 10;\n  for (; s.length;) {\n    let c = s.shift();\n    try {\n      if (r.push(JSON.parse(c)), t) return r;\n    } catch (u) {\n      if (!i--) throw u;\n      let f = +((o = u.message.match(/\\sposition\\s(\\d+)$/)) == null ? void 0 : o[1]);\n      if (!f) throw u;\n      s.unshift(c.substring(0, f), c.substring(f));\n    }\n  }\n  return r;\n}\nfunction Y(e) {\n  var t;\n  return {\n    cleaned: e.replace(I, \"\"),\n    encoded: ((t = e.match(I)) == null ? void 0 : t[0]) || \"\"\n  };\n}\nfunction T(e, t) {\n  return z(e, t);\n}\nfunction se(e) {\n  return _(e);\n}\nfunction ce(e) {\n  return H(e);\n}\nfunction ie(e) {\n  return Y(e);\n}\nvar q = Object.prototype.hasOwnProperty,\n  ee = Object.prototype.toString,\n  te = function (t, o, n) {\n    if (ee.call(o) !== \"[object Function]\") throw new TypeError(\"iterator must be a function\");\n    var r = t.length;\n    if (r === +r) for (var s = 0; s < r; s++) o.call(n, t[s], s, t);else for (var i in t) q.call(t, i) && o.call(n, t[i], i, t);\n  },\n  ne = te,\n  y = a;\nfunction a(e, t, o) {\n  if (arguments.length === 3) return a.set(e, t, o);\n  if (arguments.length === 2) return a.get(e, t);\n  var n = a.bind(a, e);\n  for (var r in a) a.hasOwnProperty(r) && (n[r] = a[r].bind(n, e));\n  return n;\n}\na.get = function (t, o) {\n  for (var n = Array.isArray(o) ? o : a.parse(o), r = 0; r < n.length; ++r) {\n    var s = n[r];\n    if (!(typeof t == \"object\" && s in t)) throw new Error(\"Invalid reference token: \" + s);\n    t = t[s];\n  }\n  return t;\n};\na.set = function (t, o, n) {\n  var r = Array.isArray(o) ? o : a.parse(o),\n    s = r[0];\n  if (r.length === 0) throw Error(\"Can not set the root object\");\n  for (var i = 0; i < r.length - 1; ++i) {\n    var c = r[i];\n    typeof c != \"string\" && typeof c != \"number\" && (c = String(c)), !(c === \"__proto__\" || c === \"constructor\" || c === \"prototype\") && (c === \"-\" && Array.isArray(t) && (c = t.length), s = r[i + 1], c in t || (s.match(/^(\\d+|-)$/) ? t[c] = [] : t[c] = {}), t = t[c]);\n  }\n  return s === \"-\" && Array.isArray(t) && (s = t.length), t[s] = n, this;\n};\na.remove = function (e, t) {\n  var o = Array.isArray(t) ? t : a.parse(t),\n    n = o[o.length - 1];\n  if (n === void 0) throw new Error('Invalid JSON pointer for remove: \"' + t + '\"');\n  var r = a.get(e, o.slice(0, -1));\n  if (Array.isArray(r)) {\n    var s = +n;\n    if (n === \"\" && isNaN(s)) throw new Error('Invalid array index: \"' + n + '\"');\n    Array.prototype.splice.call(r, s, 1);\n  } else delete r[n];\n};\na.dict = function (t, o) {\n  var n = {};\n  return a.walk(t, function (r, s) {\n    n[s] = r;\n  }, o), n;\n};\na.walk = function (t, o, n) {\n  var r = [];\n  n = n || function (s) {\n    var i = Object.prototype.toString.call(s);\n    return i === \"[object Object]\" || i === \"[object Array]\";\n  }, function s(i) {\n    ne(i, function (c, u) {\n      r.push(String(u)), n(c) ? s(c) : o(c, a.compile(r)), r.pop();\n    });\n  }(t);\n};\na.has = function (t, o) {\n  try {\n    a.get(t, o);\n  } catch (n) {\n    return !1;\n  }\n  return !0;\n};\na.escape = function (t) {\n  return t.toString().replace(/~/g, \"~0\").replace(/\\//g, \"~1\");\n};\na.unescape = function (t) {\n  return t.replace(/~1/g, \"/\").replace(/~0/g, \"~\");\n};\na.parse = function (t) {\n  if (t === \"\") return [];\n  if (t.charAt(0) !== \"/\") throw new Error(\"Invalid JSON pointer: \" + t);\n  return t.substring(1).split(/\\//).map(a.unescape);\n};\na.compile = function (t) {\n  return t.length === 0 ? \"\" : \"/\" + t.map(a.escape).join(\"/\");\n};\nconst re = ({\n    pointer: e,\n    mappings: t,\n    data: o,\n    hiddenStrings: n\n  }) => {\n    const r = t[e];\n    delete t[e];\n    const s = F(o, e);\n    for (const i of s) {\n      t[i] = r;\n      const c = y.get(o, i),\n        u = T(c, n);\n      y.set(o, i, u);\n    }\n  },\n  F = (e, t = \"\") => {\n    const o = [],\n      n = y.get(e, t);\n    if (n.content) for (let r = 0; r < n.content.length; r++) n.content[r].nodeType === \"text\" ? o.push(`${t}/content/${r}/value`) : o.push(...F(e, `${t}/content/${r}`));\n    return o;\n  },\n  x = ({\n    entityId: e,\n    entityType: t,\n    space: o,\n    environment: n,\n    field: r,\n    locale: s,\n    editorInterface: i,\n    fieldType: c,\n    targetOrigin: u,\n    platform: f\n  }) => {\n    const d = {\n      origin: \"contentful.com\",\n      href: `${`${u || \"https://app.contentful.com\"}/spaces/${o}/environments/${n}`}/${t === \"Entry\" ? \"entries\" : \"assets\"}/${e}/?focusedField=${r}&focusedLocale=${s}&source=vercel-content-link`,\n      contentful: {\n        space: o,\n        environment: n,\n        field: r,\n        locale: s,\n        entity: e,\n        entityType: t,\n        editorInterface: i,\n        fieldType: c\n      }\n    };\n    return f === \"vercel\" && delete d.contentful, f === \"contentful\" && delete d.href, d;\n  },\n  W = e => [\"builtin\", \"sidebar-builtin\", \"editor-builtin\"].includes(e),\n  U = e => oe.includes(e);\nfunction j(e) {\n  if (typeof structuredClone == \"function\") return structuredClone(e);\n  try {\n    return JSON.parse(JSON.stringify(e));\n  } catch (t) {\n    return console.warn(\"Failed to clone data:\", e, t), e;\n  }\n}\nconst oe = [\"singleLine\", \"tagEditor\", \"listInput\", \"checkbox\", \"richTextEditor\", \"multipleLine\"];\nfunction C(e, t, o, n, r, s, i) {\n  const c = i ? t[i] : t;\n  switch (e) {\n    case \"Symbol\":\n      {\n        const u = T(c, o);\n        y.set(n, r, u);\n        break;\n      }\n    case \"Text\":\n      {\n        const u = T(c, o);\n        y.set(n, r, u);\n        break;\n      }\n    case \"RichText\":\n      {\n        re({\n          pointer: \"\",\n          mappings: s,\n          data: c,\n          hiddenStrings: o\n        });\n        break;\n      }\n    case \"Array\":\n      {\n        const u = c.map(f => typeof f == \"string\" ? T(f, o) : f);\n        y.set(n, r, u);\n        break;\n      }\n  }\n}\nconst ae = (e, t, o) => {\n    if (!e || !e.extensions || !e.extensions.contentSourceMaps) return console.error(\"GraphQL response does not contain Content Source Maps information.\", e), e;\n    const n = j(e),\n      {\n        spaces: r,\n        environments: s,\n        editorInterfaces: i,\n        fields: c,\n        locales: u,\n        entries: f,\n        assets: p,\n        mappings: g,\n        fieldTypes: v\n      } = n.extensions.contentSourceMaps,\n      h = n;\n    for (const d in g) {\n      const {\n          source: l\n        } = g[d],\n        m = \"entry\" in l ? f[l.entry] : p[l.asset],\n        P = \"entry\" in l ? \"Entry\" : \"Asset\";\n      if (!m) return n;\n      const S = r[m.space],\n        A = s[m.environment],\n        E = m.id,\n        w = c[l.field],\n        N = u[l.locale],\n        O = i[l.editorInterface],\n        L = v[l.fieldType];\n      if (!(W(O.widgetNamespace) && !U(O.widgetId)) && y.has(h, d)) {\n        const M = y.get(h, d);\n        if (M !== null) {\n          const B = x({\n            entityId: E,\n            entityType: P,\n            space: S,\n            environment: A,\n            field: w,\n            locale: N,\n            editorInterface: O,\n            fieldType: L,\n            targetOrigin: t,\n            platform: o\n          });\n          C(L, M, B, h, d, g);\n        }\n      }\n    }\n    return n;\n  },\n  $ = (e, t, o, n, r) => {\n    if (!e.fields) return;\n    const {\n      contentSourceMaps: s\n    } = e.sys;\n    if (!s) {\n      console.error(\"Content source maps data is missing\");\n      return;\n    }\n    const {\n      mappings: i\n    } = s;\n    for (const c in i) {\n      const {\n          source: u\n        } = i[c],\n        f = e.sys.space.sys.id,\n        p = e.sys.environment.sys.id,\n        g = e.sys.id,\n        v = e.sys.type,\n        h = t[u.fieldType],\n        d = o[u.editorInterface];\n      if (W(d.widgetNamespace) && !U(d.widgetId)) continue;\n      const l = c.startsWith(\"/\") ? c : `/${c}`;\n      if (y.has(e, l)) {\n        const m = y.get(e, l);\n        if (m === null) return;\n        const S = l.split(\"/\").pop();\n        if (!S) {\n          console.error(\"Field name could not be extracted from the pointer\", l);\n          return;\n        }\n        const A = e.sys.locale;\n        if (A) {\n          const E = x({\n            entityId: g,\n            entityType: v,\n            space: f,\n            environment: p,\n            field: S,\n            locale: A,\n            editorInterface: d,\n            fieldType: h,\n            targetOrigin: n,\n            platform: r\n          });\n          C(h, m, E, e, l, i);\n        } else Object.keys(m).forEach(w => {\n          const N = x({\n            entityId: g,\n            entityType: v,\n            space: f,\n            environment: p,\n            field: S,\n            locale: w,\n            editorInterface: d,\n            fieldType: h,\n            targetOrigin: n,\n            platform: r\n          });\n          C(h, m, N, e, `${l}/${w}`, i, w);\n        });\n      }\n    }\n  },\n  ue = (e, t, o) => {\n    var r;\n    const n = j(e);\n    if (n.sys && \"items\" in n) {\n      const s = n;\n      if (!((r = s.sys) != null && r.contentSourceMapsLookup)) return console.error(\"Content source maps lookup data is missing\"), s;\n      const {\n          contentSourceMapsLookup: {\n            fieldTypes: i,\n            editorInterfaces: c\n          }\n        } = s.sys,\n        {\n          items: u,\n          includes: f\n        } = s;\n      u.forEach(p => $(p, i, c, t, o)), f && f.Entry && f.Entry.forEach(p => $(p, i, c, t, o)), f && f.Asset && f.Asset.forEach(p => $(p, i, c, t, o));\n    } else {\n      const s = n;\n      if (!s.sys.contentSourceMapsLookup) return console.error(\"Content source maps lookup data is missing\"), s;\n      $(s, s.sys.contentSourceMapsLookup.fieldTypes, s.sys.contentSourceMapsLookup.editorInterfaces, t, o);\n    }\n    return n;\n  };\nexport { oe as SUPPORTED_WIDGETS, j as clone, T as combine, x as createSourceMapMetadata, ce as decode, se as encode, ue as encodeCPAResponse, C as encodeField, ae as encodeGraphQLResponse, re as encodeRichTextValue, W as isBuiltinNamespace, U as isSupportedWidget, ie as splitEncoding };","map":{"version":3,"names":["R","a","b","c","d","e","f","V","Array","fill","String","fromCodePoint","join","J","_","t","JSON","stringify","from","map","o","n","charCodeAt","Error","toString","padStart","r","D","Number","isNaN","test","Date","parse","Q","URL","startsWith","z","Z","Object","fromEntries","entries","reverse","k","G","values","I","RegExp","H","match","K","length","X","s","slice","i","codePointAt","unshift","fromCharCode","parseInt","shift","indexOf","split","filter","Boolean","u","push","message","substring","Y","cleaned","replace","encoded","T","se","ce","ie","q","prototype","hasOwnProperty","ee","te","foreach","call","TypeError","ne","y","arguments","set","get","bind","isArray","remove","splice","dict","walk","compile","pop","has","escape","unescape","charAt","re","encodeRichTextValue","pointer","mappings","data","hiddenStrings","F","findRichTextNodes","content","nodeType","x","createSourceMapMetadata","entityId","entityType","space","environment","field","locale","editorInterface","fieldType","targetOrigin","platform","origin","href","contentful","entity","W","includes","U","oe","j","structuredClone","console","warn","C","ae","encodeGraphQLResponse","extensions","contentSourceMaps","error","spaces","environments","editorInterfaces","fields","locales","assets","p","g","fieldTypes","v","h","source","l","m","entry","asset","P","S","A","E","id","w","N","O","L","widgetNamespace","widgetId","M","B","$","applyEncoding","sys","type","keys","forEach","ue","encodeCPAResponse","contentSourceMapsLookup","items","Entry","Asset"],"sources":["C:\\Users\\ainge\\OneDrive\\Documents\\GitHub\\mr-ingerson-blog\\node_modules\\node_modules\\@vercel\\stega\\dist\\index.mjs","C:\\Users\\ainge\\OneDrive\\Documents\\GitHub\\mr-ingerson-blog\\node_modules\\@contentful\\content-source-maps\\src\\encode.ts","C:\\Users\\ainge\\OneDrive\\Documents\\GitHub\\mr-ingerson-blog\\node_modules\\node_modules\\foreach\\index.js","C:\\Users\\ainge\\OneDrive\\Documents\\GitHub\\mr-ingerson-blog\\node_modules\\node_modules\\json-pointer\\index.js","C:\\Users\\ainge\\OneDrive\\Documents\\GitHub\\mr-ingerson-blog\\node_modules\\@contentful\\content-source-maps\\src\\richText.ts","C:\\Users\\ainge\\OneDrive\\Documents\\GitHub\\mr-ingerson-blog\\node_modules\\@contentful\\content-source-maps\\src\\utils.ts","C:\\Users\\ainge\\OneDrive\\Documents\\GitHub\\mr-ingerson-blog\\node_modules\\@contentful\\content-source-maps\\src\\graphql\\encodeGraphQLResponse.ts","C:\\Users\\ainge\\OneDrive\\Documents\\GitHub\\mr-ingerson-blog\\node_modules\\@contentful\\content-source-maps\\src\\rest\\encodeCPAResponse.ts"],"sourcesContent":["var s={0:8203,1:8204,2:8205,3:8290,4:8291,5:8288,6:65279,7:8289,8:119155,9:119156,a:119157,b:119158,c:119159,d:119160,e:119161,f:119162},c={0:8203,1:8204,2:8205,3:65279},u=new Array(4).fill(String.fromCodePoint(c[0])).join(\"\"),m=String.fromCharCode(0);function E(t){let e=JSON.stringify(t);return`${u}${Array.from(e).map(r=>{let n=r.charCodeAt(0);if(n>255)throw new Error(`Only ASCII edit info can be encoded. Error attempting to encode ${e} on character ${r} (${n})`);return Array.from(n.toString(4).padStart(4,\"0\")).map(o=>String.fromCodePoint(c[o])).join(\"\")}).join(\"\")}`}function y(t){let e=JSON.stringify(t);return Array.from(e).map(r=>{let n=r.charCodeAt(0);if(n>255)throw new Error(`Only ASCII edit info can be encoded. Error attempting to encode ${e} on character ${r} (${n})`);return Array.from(n.toString(16).padStart(2,\"0\")).map(o=>String.fromCodePoint(s[o])).join(\"\")}).join(\"\")}function I(t){return!Number.isNaN(Number(t))||/[a-z]/i.test(t)&&!/\\d+(?:[-:\\/]\\d+){2}(?:T\\d+(?:[-:\\/]\\d+){1,2}(\\.\\d+)?Z?)?/.test(t)?!1:Boolean(Date.parse(t))}function T(t){try{new URL(t,t.startsWith(\"/\")?\"https://acme.com\":void 0)}catch{return!1}return!0}function C(t,e,r=\"auto\"){return r===!0||r===\"auto\"&&(I(t)||T(t))?t:`${t}${E(e)}`}var x=Object.fromEntries(Object.entries(c).map(t=>t.reverse())),g=Object.fromEntries(Object.entries(s).map(t=>t.reverse())),S=`${Object.values(s).map(t=>`\\\\u{${t.toString(16)}}`).join(\"\")}`,f=new RegExp(`[${S}]{4,}`,\"gu\");function G(t){let e=t.match(f);if(!!e)return h(e[0],!0)[0]}function $(t){let e=t.match(f);if(!!e)return e.map(r=>h(r)).flat()}function h(t,e=!1){let r=Array.from(t);if(r.length%2===0){if(r.length%4||!t.startsWith(u))return A(r,e)}else throw new Error(\"Encoded data has invalid length\");let n=[];for(let o=r.length*.25;o--;){let p=r.slice(o*4,o*4+4).map(d=>x[d.codePointAt(0)]).join(\"\");n.unshift(String.fromCharCode(parseInt(p,4)))}if(e){n.shift();let o=n.indexOf(m);return o===-1&&(o=n.length),[JSON.parse(n.slice(0,o).join(\"\"))]}return n.join(\"\").split(m).filter(Boolean).map(o=>JSON.parse(o))}function A(t,e){var d;let r=[];for(let i=t.length*.5;i--;){let a=`${g[t[i*2].codePointAt(0)]}${g[t[i*2+1].codePointAt(0)]}`;r.unshift(String.fromCharCode(parseInt(a,16)))}let n=[],o=[r.join(\"\")],p=10;for(;o.length;){let i=o.shift();try{if(n.push(JSON.parse(i)),e)return n}catch(a){if(!p--)throw a;let l=+((d=a.message.match(/\\sposition\\s(\\d+)$/))==null?void 0:d[1]);if(!l)throw a;o.unshift(i.substring(0,l),i.substring(l))}}return n}function _(t){var e;return{cleaned:t.replace(f,\"\"),encoded:((e=t.match(f))==null?void 0:e[0])||\"\"}}function O(t){return t&&JSON.parse(_(JSON.stringify(t)).cleaned)}export{f as VERCEL_STEGA_REGEX,y as legacyStegaEncode,O as vercelStegaClean,C as vercelStegaCombine,G as vercelStegaDecode,$ as vercelStegaDecodeAll,E as vercelStegaEncode,_ as vercelStegaSplit};\n","import {\n  vercelStegaCombine,\n  vercelStegaDecode,\n  vercelStegaEncode,\n  vercelStegaSplit,\n} from '@vercel/stega';\n\nimport type { SourceMapMetadata } from './types.js';\n\nexport function combine(text: string, metadata: SourceMapMetadata): string {\n  return vercelStegaCombine(text, metadata);\n}\n\nexport function encode(metadata: SourceMapMetadata): string {\n  return vercelStegaEncode(metadata);\n}\n\nexport function decode(text: string): SourceMapMetadata | undefined {\n  return vercelStegaDecode(text);\n}\n\nexport function splitEncoding(text: string): {\n  /** The original string with encoded substring removed */\n  cleaned: string;\n  /** The encoded substring from the original string */\n  encoded: string;\n} {\n  return vercelStegaSplit(text);\n}\n","\nvar hasOwn = Object.prototype.hasOwnProperty;\nvar toString = Object.prototype.toString;\n\nmodule.exports = function forEach (obj, fn, ctx) {\n    if (toString.call(fn) !== '[object Function]') {\n        throw new TypeError('iterator must be a function');\n    }\n    var l = obj.length;\n    if (l === +l) {\n        for (var i = 0; i < l; i++) {\n            fn.call(ctx, obj[i], i, obj);\n        }\n    } else {\n        for (var k in obj) {\n            if (hasOwn.call(obj, k)) {\n                fn.call(ctx, obj[k], k, obj);\n            }\n        }\n    }\n};\n\n","'use strict';\n\nvar each = require('foreach');\nmodule.exports = api;\n\n\n/**\n * Convenience wrapper around the api.\n * Calls `.get` when called with an `object` and a `pointer`.\n * Calls `.set` when also called with `value`.\n * If only supplied `object`, returns a partially applied function, mapped to the object.\n *\n * @param {Object} obj\n * @param {String|Array} pointer\n * @param value\n * @returns {*}\n */\n\nfunction api (obj, pointer, value) {\n    // .set()\n    if (arguments.length === 3) {\n        return api.set(obj, pointer, value);\n    }\n    // .get()\n    if (arguments.length === 2) {\n        return api.get(obj, pointer);\n    }\n    // Return a partially applied function on `obj`.\n    var wrapped = api.bind(api, obj);\n\n    // Support for oo style\n    for (var name in api) {\n        if (api.hasOwnProperty(name)) {\n            wrapped[name] = api[name].bind(wrapped, obj);\n        }\n    }\n    return wrapped;\n}\n\n\n/**\n * Lookup a json pointer in an object\n *\n * @param {Object} obj\n * @param {String|Array} pointer\n * @returns {*}\n */\napi.get = function get (obj, pointer) {\n    var refTokens = Array.isArray(pointer) ? pointer : api.parse(pointer);\n\n    for (var i = 0; i < refTokens.length; ++i) {\n        var tok = refTokens[i];\n        if (!(typeof obj == 'object' && tok in obj)) {\n            throw new Error('Invalid reference token: ' + tok);\n        }\n        obj = obj[tok];\n    }\n    return obj;\n};\n\n/**\n * Sets a value on an object\n *\n * @param {Object} obj\n * @param {String|Array} pointer\n * @param value\n */\napi.set = function set (obj, pointer, value) {\n    var refTokens = Array.isArray(pointer) ? pointer : api.parse(pointer),\n      nextTok = refTokens[0];\n\n    if (refTokens.length === 0) {\n      throw Error('Can not set the root object');\n    }\n\n    for (var i = 0; i < refTokens.length - 1; ++i) {\n        var tok = refTokens[i];\n        if (typeof tok !== 'string' && typeof tok !== 'number') {\n          tok = String(tok)\n        }\n        if (tok === \"__proto__\" || tok === \"constructor\" || tok === \"prototype\") {\n            continue\n        }\n        if (tok === '-' && Array.isArray(obj)) {\n          tok = obj.length;\n        }\n        nextTok = refTokens[i + 1];\n\n        if (!(tok in obj)) {\n            if (nextTok.match(/^(\\d+|-)$/)) {\n                obj[tok] = [];\n            } else {\n                obj[tok] = {};\n            }\n        }\n        obj = obj[tok];\n    }\n    if (nextTok === '-' && Array.isArray(obj)) {\n      nextTok = obj.length;\n    }\n    obj[nextTok] = value;\n    return this;\n};\n\n/**\n * Removes an attribute\n *\n * @param {Object} obj\n * @param {String|Array} pointer\n */\napi.remove = function (obj, pointer) {\n    var refTokens = Array.isArray(pointer) ? pointer : api.parse(pointer);\n    var finalToken = refTokens[refTokens.length -1];\n    if (finalToken === undefined) {\n        throw new Error('Invalid JSON pointer for remove: \"' + pointer + '\"');\n    }\n\n    var parent = api.get(obj, refTokens.slice(0, -1));\n    if (Array.isArray(parent)) {\n      var index = +finalToken;\n      if (finalToken === '' && isNaN(index)) {\n        throw new Error('Invalid array index: \"' + finalToken + '\"');\n      }\n\n      Array.prototype.splice.call(parent, index, 1);\n    } else {\n      delete parent[finalToken];\n    }\n};\n\n/**\n * Returns a (pointer -> value) dictionary for an object\n *\n * @param obj\n * @param {function} descend\n * @returns {}\n */\napi.dict = function dict (obj, descend) {\n    var results = {};\n    api.walk(obj, function (value, pointer) {\n        results[pointer] = value;\n    }, descend);\n    return results;\n};\n\n/**\n * Iterates over an object\n * Iterator: function (value, pointer) {}\n *\n * @param obj\n * @param {function} iterator\n * @param {function} descend\n */\napi.walk = function walk (obj, iterator, descend) {\n    var refTokens = [];\n\n    descend = descend || function (value) {\n        var type = Object.prototype.toString.call(value);\n        return type === '[object Object]' || type === '[object Array]';\n    };\n\n    (function next (cur) {\n        each(cur, function (value, key) {\n            refTokens.push(String(key));\n            if (descend(value)) {\n                next(value);\n            } else {\n                iterator(value, api.compile(refTokens));\n            }\n            refTokens.pop();\n        });\n    }(obj));\n};\n\n/**\n * Tests if an object has a value for a json pointer\n *\n * @param obj\n * @param pointer\n * @returns {boolean}\n */\napi.has = function has (obj, pointer) {\n    try {\n        api.get(obj, pointer);\n    } catch (e) {\n        return false;\n    }\n    return true;\n};\n\n/**\n * Escapes a reference token\n *\n * @param str\n * @returns {string}\n */\napi.escape = function escape (str) {\n    return str.toString().replace(/~/g, '~0').replace(/\\//g, '~1');\n};\n\n/**\n * Unescapes a reference token\n *\n * @param str\n * @returns {string}\n */\napi.unescape = function unescape (str) {\n    return str.replace(/~1/g, '/').replace(/~0/g, '~');\n};\n\n/**\n * Converts a json pointer into a array of reference tokens\n *\n * @param pointer\n * @returns {Array}\n */\napi.parse = function parse (pointer) {\n    if (pointer === '') { return []; }\n    if (pointer.charAt(0) !== '/') { throw new Error('Invalid JSON pointer: ' + pointer); }\n    return pointer.substring(1).split(/\\//).map(api.unescape);\n};\n\n/**\n * Builds a json pointer from a array of reference tokens\n *\n * @param refTokens\n * @returns {string}\n */\napi.compile = function compile (refTokens) {\n    if (refTokens.length === 0) { return ''; }\n    return '/' + refTokens.map(api.escape).join('/');\n};\n","import { get, set } from 'json-pointer';\n\nimport { combine } from './encode.js';\nimport type { CPAMappings, GraphQLMappings, SourceMapMetadata } from './types.js';\n\nexport const encodeRichTextValue = ({\n  pointer,\n  mappings,\n  data,\n  hiddenStrings,\n}: {\n  pointer: string;\n  mappings: CPAMappings | GraphQLMappings;\n  data: Node;\n  hiddenStrings: SourceMapMetadata;\n}) => {\n  const source = mappings[pointer];\n  // remove old pointer to rich text field as we will just be mapping the text nodes\n  delete mappings[pointer];\n\n  const textNodes = findRichTextNodes(data, pointer);\n  for (const textNode of textNodes) {\n    mappings[textNode] = source;\n    const currentTextNodeValue = get(data, textNode);\n    const encodedValue = combine(currentTextNodeValue, hiddenStrings);\n    set(data, textNode, encodedValue);\n  }\n};\n\nconst findRichTextNodes = (data: Node, currentPath = ''): string[] => {\n  const textNodes = [];\n  const node = get(data, currentPath);\n\n  if (node.content) {\n    for (let i = 0; i < node.content.length; i++) {\n      if (node.content[i].nodeType === 'text') {\n        textNodes.push(`${currentPath}/content/${i}/value`);\n      } else {\n        textNodes.push(...findRichTextNodes(data, `${currentPath}/content/${i}`));\n      }\n    }\n  }\n\n  return textNodes;\n};\n","import { set } from 'json-pointer';\n\nimport { combine } from './encode.js';\nimport { encodeRichTextValue } from './richText.js';\nimport type {\n  CPAEntry,\n  CPAMappings,\n  CreateSourceMapParams,\n  FieldType,\n  GraphQLMappings,\n  GraphQLResponse,\n  SourceMapMetadata,\n  WidgetId,\n  WidgetNamespace,\n} from './types.js';\n\nexport const createSourceMapMetadata = ({\n  entityId,\n  entityType,\n  space,\n  environment,\n  field,\n  locale,\n  editorInterface,\n  fieldType,\n  targetOrigin,\n  platform,\n}: CreateSourceMapParams): SourceMapMetadata => {\n  const targetOriginUrl = targetOrigin || 'https://app.contentful.com';\n  const basePath = `${targetOriginUrl}/spaces/${space}/environments/${environment}`;\n  const entityRoute = entityType === 'Entry' ? 'entries' : 'assets';\n  //href is used only by Vercel to open the entry in the Contentful web app\n  const href = `${basePath}/${entityRoute}/${entityId}/?focusedField=${field}&focusedLocale=${locale}&source=vercel-content-link`;\n\n  const result: SourceMapMetadata = {\n    origin: 'contentful.com',\n    href,\n    contentful: {\n      space,\n      environment,\n      field,\n      locale,\n      entity: entityId,\n      entityType,\n      editorInterface,\n      fieldType,\n    },\n  };\n\n  // If the user has specified a platform, we remove the fields that are not relevant to that platform\n  if (platform === 'vercel') {\n    delete result.contentful;\n  }\n\n  if (platform === 'contentful') {\n    delete result.href;\n  }\n\n  return result;\n};\n\nexport const isBuiltinNamespace = (namespace: WidgetNamespace) =>\n  ['builtin', 'sidebar-builtin', 'editor-builtin'].includes(namespace);\nexport const isSupportedWidget = (widgetId: WidgetId) => SUPPORTED_WIDGETS.includes(widgetId);\n\n/**\n * Clones the incoming element into a new one, to prevent modification on the original object\n * Hint: It uses the structuredClone which is only available in modern browsers,\n * for older one it uses the JSON.parse(JSON.stringify) hack.\n */\nexport function clone<T extends Record<string, unknown> | Array<unknown>>(incoming: T): T {\n  if (typeof structuredClone === 'function') {\n    return structuredClone(incoming);\n  }\n\n  try {\n    return JSON.parse(JSON.stringify(incoming));\n  } catch (err) {\n    console.warn('Failed to clone data:', incoming, err);\n    return incoming;\n  }\n}\n\nexport const SUPPORTED_WIDGETS: WidgetId[] = [\n  'singleLine',\n  'tagEditor',\n  'listInput',\n  'checkbox',\n  'richTextEditor',\n  'multipleLine',\n];\n\nexport function encodeField(\n  fieldType: FieldType,\n  currentValue: any,\n  hiddenStrings: SourceMapMetadata,\n  target: GraphQLResponse | CPAEntry,\n  pointer: string,\n  mappings: CPAMappings | GraphQLMappings,\n  locale?: string,\n) {\n  // Determine the value based on locale (if provided)\n  const value = locale ? currentValue[locale] : currentValue;\n\n  // Process based on fieldType\n  switch (fieldType) {\n    case 'Symbol': {\n      const encodedValue = combine(value, hiddenStrings);\n      set(target, pointer, encodedValue);\n      break;\n    }\n\n    case 'Text': {\n      const encodedValue = combine(value, hiddenStrings);\n      set(target, pointer, encodedValue);\n      break;\n    }\n\n    case 'RichText': {\n      encodeRichTextValue({\n        pointer: '',\n        mappings,\n        data: value,\n        hiddenStrings,\n      });\n      break;\n    }\n\n    case 'Array': {\n      const encodedArray = value.map((item: unknown) => {\n        if (typeof item === 'string') {\n          return combine(item, hiddenStrings);\n        } else {\n          return item; // Return the item unchanged if it's not a string\n        }\n      });\n      set(target, pointer, encodedArray);\n      break;\n    }\n  }\n}\n","import { get, has } from 'json-pointer';\n\nimport type { CreateSourceMapParams, GraphQLResponse } from '../types.js';\nimport {\n  clone,\n  createSourceMapMetadata,\n  encodeField,\n  isBuiltinNamespace,\n  isSupportedWidget,\n} from '../utils.js';\n\nexport const encodeGraphQLResponse = (\n  originalGraphqlResponse: GraphQLResponse,\n  targetOrigin?: CreateSourceMapParams['targetOrigin'],\n  platform?: CreateSourceMapParams['platform'],\n): GraphQLResponse => {\n  if (\n    !originalGraphqlResponse ||\n    !originalGraphqlResponse.extensions ||\n    !originalGraphqlResponse.extensions.contentSourceMaps\n  ) {\n    console.error(\n      'GraphQL response does not contain Content Source Maps information.',\n      originalGraphqlResponse,\n    );\n    return originalGraphqlResponse;\n  }\n  const modifiedGraphqlResponse = clone(\n    originalGraphqlResponse as unknown as Record<string, unknown>,\n  ) as unknown as GraphQLResponse;\n  const {\n    spaces,\n    environments,\n    editorInterfaces,\n    fields,\n    locales,\n    entries,\n    assets,\n    mappings,\n    fieldTypes,\n  } = modifiedGraphqlResponse.extensions.contentSourceMaps;\n  const target = modifiedGraphqlResponse;\n\n  for (const pointer in mappings) {\n    const { source } = mappings[pointer];\n\n    const entity = 'entry' in source ? entries[source.entry] : assets[source.asset];\n    const entityType = 'entry' in source ? 'Entry' : 'Asset';\n\n    if (!entity) {\n      return modifiedGraphqlResponse;\n    }\n\n    const space = spaces[entity.space];\n    const environment = environments[entity.environment];\n    const entityId = entity.id;\n    const field = fields[source.field];\n    const locale = locales[source.locale];\n    const editorInterface = editorInterfaces[source.editorInterface];\n    const fieldType = fieldTypes[source.fieldType];\n\n    // Skip unsupported widgets\n    if (\n      isBuiltinNamespace(editorInterface.widgetNamespace) &&\n      !isSupportedWidget(editorInterface.widgetId)\n    ) {\n      continue;\n    }\n\n    if (has(target, pointer)) {\n      const currentValue = get(target, pointer);\n\n      if (currentValue !== null) {\n        const hiddenStrings = createSourceMapMetadata({\n          entityId,\n          entityType,\n          space,\n          environment,\n          field,\n          locale,\n          editorInterface,\n          fieldType,\n          targetOrigin,\n          platform,\n        });\n\n        encodeField(fieldType, currentValue, hiddenStrings, target, pointer, mappings);\n      }\n    } else {\n      //@TODO - add Sentry logging\n      // console.warn(`Pointer ${pointer} not found in the entry`, target);\n    }\n  }\n  return modifiedGraphqlResponse;\n};\n","import { get, has } from 'json-pointer';\n\nimport type {\n  CPAEntry,\n  CPAEntryCollection,\n  EditorInterfaceSource,\n  FieldType,\n  CreateSourceMapParams,\n} from '../types.js';\nimport {\n  clone,\n  createSourceMapMetadata,\n  encodeField,\n  isBuiltinNamespace,\n  isSupportedWidget,\n} from '../utils.js';\n\nconst applyEncoding = (\n  target: CPAEntry,\n  fieldTypes: FieldType[],\n  editorInterfaces: EditorInterfaceSource[],\n  targetOrigin?: CreateSourceMapParams['targetOrigin'],\n  platform?: CreateSourceMapParams['platform'],\n) => {\n  if (!target.fields) {\n    return;\n  }\n\n  const { contentSourceMaps } = target.sys;\n\n  if (!contentSourceMaps) {\n    console.error('Content source maps data is missing');\n    return;\n  }\n\n  const { mappings } = contentSourceMaps;\n\n  for (const pointer in mappings) {\n    const { source } = mappings[pointer];\n    const space = target.sys.space.sys.id;\n    const environment = target.sys.environment.sys.id;\n    const entityId = target.sys.id;\n    const entityType = target.sys.type;\n    const fieldType = fieldTypes[source.fieldType];\n    const editorInterface = editorInterfaces[source.editorInterface];\n\n    // Skip unsupported widgets\n    if (\n      isBuiltinNamespace(editorInterface.widgetNamespace) &&\n      !isSupportedWidget(editorInterface.widgetId)\n    ) {\n      continue;\n    }\n\n    const formattedPointer = pointer.startsWith('/') ? pointer : `/${pointer}`;\n\n    if (has(target, formattedPointer)) {\n      const currentValue = get(target, formattedPointer);\n      if (currentValue === null) {\n        return;\n      }\n      const fieldParts = formattedPointer.split('/'); // Split the pointer into parts\n      const field = fieldParts.pop(); // Get the last part, which is the field name\n      if (!field) {\n        console.error('Field name could not be extracted from the pointer', formattedPointer);\n        return;\n      }\n      const locale = target.sys.locale;\n\n      // Determine if we are dealing with multiple locale values in the response or just a single locale\n      if (locale) {\n        const hiddenStrings = createSourceMapMetadata({\n          entityId,\n          entityType,\n          space,\n          environment,\n          field,\n          locale,\n          editorInterface,\n          fieldType,\n          targetOrigin,\n          platform,\n        });\n\n        encodeField(fieldType, currentValue, hiddenStrings, target, formattedPointer, mappings);\n      } else {\n        const locales = Object.keys(currentValue);\n        locales.forEach((locale) => {\n          const hiddenStrings = createSourceMapMetadata({\n            entityId,\n            entityType,\n            space,\n            environment,\n            field,\n            locale,\n            editorInterface,\n            fieldType,\n            targetOrigin,\n            platform,\n          });\n\n          encodeField(\n            fieldType,\n            currentValue,\n            hiddenStrings,\n            target,\n            `${formattedPointer}/${locale}`,\n            mappings,\n            locale,\n          );\n        });\n      }\n    } else {\n      //@TODO - add Sentry logging\n      // console.warn(`Pointer ${pointer} not found in the entry`, target);\n    }\n  }\n};\n\nexport const encodeCPAResponse = (\n  CPAResponse: CPAEntry | CPAEntryCollection,\n  targetOrigin?: CreateSourceMapParams['targetOrigin'],\n  platform?: CreateSourceMapParams['platform'],\n): CPAEntry | CPAEntryCollection => {\n  const modifiedCPAResponse = clone(\n    CPAResponse as unknown as Record<string, unknown>,\n  ) as unknown as CPAEntry | CPAEntryCollection;\n\n  // Entity collections\n  if (modifiedCPAResponse.sys && 'items' in (modifiedCPAResponse as CPAEntryCollection)) {\n    const collection = modifiedCPAResponse as CPAEntryCollection;\n    if (!collection.sys?.contentSourceMapsLookup) {\n      console.error('Content source maps lookup data is missing');\n      return collection;\n    }\n    const {\n      contentSourceMapsLookup: { fieldTypes, editorInterfaces },\n    } = collection.sys;\n    const { items, includes } = collection;\n\n    items.forEach((target) =>\n      applyEncoding(target, fieldTypes, editorInterfaces, targetOrigin, platform),\n    );\n    if (includes && includes.Entry) {\n      includes.Entry.forEach((entry) =>\n        applyEncoding(entry, fieldTypes, editorInterfaces, targetOrigin, platform),\n      );\n    }\n    if (includes && includes.Asset) {\n      includes.Asset.forEach((asset) =>\n        applyEncoding(asset, fieldTypes, editorInterfaces, targetOrigin, platform),\n      );\n    }\n    // Single entity\n  } else {\n    const entry = modifiedCPAResponse as CPAEntry;\n    if (!entry.sys.contentSourceMapsLookup) {\n      console.error('Content source maps lookup data is missing');\n      return entry;\n    }\n\n    applyEncoding(\n      entry,\n      entry.sys.contentSourceMapsLookup.fieldTypes,\n      entry.sys.contentSourceMapsLookup.editorInterfaces,\n      targetOrigin,\n      platform,\n    );\n  }\n\n  return modifiedCPAResponse;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}