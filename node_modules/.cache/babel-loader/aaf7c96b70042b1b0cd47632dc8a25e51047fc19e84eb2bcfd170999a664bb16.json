{"ast":null,"code":"import resolveResponse from 'contentful-resolve-response';\nimport { freezeSys, toPlainObject, createRequestConfig } from 'contentful-sdk-core';\nimport mixinStringifySafe from './mixins/stringify-safe.js';\n\n/**\r\n * Retrieves all the available pages for a sync operation\r\n */\nasync function pagedSync(http, query, options) {\n  if (!query || !query.initial && !query.nextSyncToken && !query.nextPageToken) {\n    throw new Error('Please provide one of `initial`, `nextSyncToken` or `nextPageToken` parameters for syncing');\n  }\n  if (query['content_type'] && !query.type) {\n    query.type = 'Entry';\n  } else if (query['content_type'] && query.type && query.type !== 'Entry') {\n    throw new Error('When using the `content_type` filter your `type` parameter cannot be different from `Entry`.');\n  }\n  const defaultOptions = {\n    withoutLinkResolution: false,\n    withoutUnresolvableLinks: false,\n    paginate: true\n  };\n  const {\n    withoutLinkResolution,\n    withoutUnresolvableLinks,\n    paginate\n  } = Object.assign(Object.assign({}, defaultOptions), options);\n  const response = await getSyncPage(http, [], query, {\n    paginate\n  });\n  // clones response.items used in includes because we don't want these to be mutated\n  if (!withoutLinkResolution) {\n    response.items = resolveResponse(response, {\n      removeUnresolved: withoutUnresolvableLinks,\n      itemEntryPoints: ['fields']\n    });\n  }\n  // maps response items again after getters are attached\n  const mappedResponseItems = mapResponseItems(response.items);\n  if (response.nextSyncToken) {\n    mappedResponseItems.nextSyncToken = response.nextSyncToken;\n  }\n  if (response.nextPageToken) {\n    mappedResponseItems.nextPageToken = response.nextPageToken;\n  }\n  return freezeSys(mixinStringifySafe(toPlainObject(mappedResponseItems)));\n}\n/**\r\n * @private\r\n * @param items\r\n * @returns Entities mapped to an object for each entity type\r\n */\nfunction mapResponseItems(items) {\n  const reducer = type => {\n    return (accumulated, item) => {\n      if (item.sys.type === type) {\n        accumulated.push(toPlainObject(item));\n      }\n      return accumulated;\n    };\n  };\n  return {\n    entries: items.reduce(reducer('Entry'), []),\n    assets: items.reduce(reducer('Asset'), []),\n    deletedEntries: items.reduce(reducer('DeletedEntry'), []),\n    deletedAssets: items.reduce(reducer('DeletedAsset'), [])\n  };\n}\nfunction createRequestQuery(originalQuery) {\n  if (originalQuery.nextPageToken) {\n    return {\n      sync_token: originalQuery.nextPageToken\n    };\n  }\n  if (originalQuery.nextSyncToken) {\n    return {\n      sync_token: originalQuery.nextSyncToken\n    };\n  }\n  if (originalQuery.sync_token) {\n    return {\n      sync_token: originalQuery.sync_token\n    };\n  }\n  return originalQuery;\n}\n/**\r\n * If the response contains a nextPageUrl, extracts the sync token to get the\r\n * next page and calls itself again with that token.\r\n * Otherwise, if the response contains a nextSyncUrl, extracts the sync token\r\n * and returns it.\r\n * On each call of this function, any retrieved items are collected in the\r\n * supplied items array, which gets returned in the end.\r\n */\nasync function getSyncPage(http, items, query, {\n  paginate\n}) {\n  const requestQuery = createRequestQuery(query);\n  const response = await http.get('sync', createRequestConfig({\n    query: requestQuery\n  }));\n  const data = response.data || {};\n  items = items.concat(data.items || []);\n  if (data.nextPageUrl) {\n    if (paginate) {\n      delete requestQuery.initial;\n      requestQuery.sync_token = getToken(data.nextPageUrl);\n      return getSyncPage(http, items, requestQuery, {\n        paginate\n      });\n    }\n    return {\n      items,\n      nextPageToken: getToken(data.nextPageUrl)\n    };\n  } else if (data.nextSyncUrl) {\n    return {\n      items,\n      nextSyncToken: getToken(data.nextSyncUrl)\n    };\n  } else {\n    return {\n      items: []\n    };\n  }\n}\n/**\r\n * Extracts token out of an url\r\n * @private\r\n */\nfunction getToken(url) {\n  const urlParts = url.split('?');\n  return urlParts.length > 0 ? urlParts[1].replace('sync_token=', '') : '';\n}\nexport { pagedSync as default };","map":{"version":3,"names":["resolveResponse","freezeSys","toPlainObject","createRequestConfig","mixinStringifySafe","pagedSync","http","query","options","initial","nextSyncToken","nextPageToken","Error","type","defaultOptions","withoutLinkResolution","withoutUnresolvableLinks","paginate","Object","assign","response","getSyncPage","items","removeUnresolved","itemEntryPoints","mappedResponseItems","mapResponseItems","reducer","accumulated","item","sys","push","entries","reduce","assets","deletedEntries","deletedAssets","createRequestQuery","originalQuery","sync_token","requestQuery","get","data","concat","nextPageUrl","getToken","nextSyncUrl","url","urlParts","split","length","replace","default"],"sources":["C:/Users/ainge/OneDrive/Documents/GitHub/mr-ingerson-blog/node_modules/contentful/dist/esm/paged-sync.js"],"sourcesContent":["import resolveResponse from 'contentful-resolve-response';\r\nimport { freezeSys, toPlainObject, createRequestConfig } from 'contentful-sdk-core';\r\nimport mixinStringifySafe from './mixins/stringify-safe.js';\r\n\r\n/**\r\n * Retrieves all the available pages for a sync operation\r\n */\r\nasync function pagedSync(http, query, options) {\r\n    if (!query || (!query.initial && !query.nextSyncToken && !query.nextPageToken)) {\r\n        throw new Error('Please provide one of `initial`, `nextSyncToken` or `nextPageToken` parameters for syncing');\r\n    }\r\n    if (query['content_type'] && !query.type) {\r\n        query.type = 'Entry';\r\n    }\r\n    else if (query['content_type'] && query.type && query.type !== 'Entry') {\r\n        throw new Error('When using the `content_type` filter your `type` parameter cannot be different from `Entry`.');\r\n    }\r\n    const defaultOptions = {\r\n        withoutLinkResolution: false,\r\n        withoutUnresolvableLinks: false,\r\n        paginate: true,\r\n    };\r\n    const { withoutLinkResolution, withoutUnresolvableLinks, paginate } = Object.assign(Object.assign({}, defaultOptions), options);\r\n    const response = await getSyncPage(http, [], query, { paginate });\r\n    // clones response.items used in includes because we don't want these to be mutated\r\n    if (!withoutLinkResolution) {\r\n        response.items = resolveResponse(response, {\r\n            removeUnresolved: withoutUnresolvableLinks,\r\n            itemEntryPoints: ['fields'],\r\n        });\r\n    }\r\n    // maps response items again after getters are attached\r\n    const mappedResponseItems = mapResponseItems(response.items);\r\n    if (response.nextSyncToken) {\r\n        mappedResponseItems.nextSyncToken = response.nextSyncToken;\r\n    }\r\n    if (response.nextPageToken) {\r\n        mappedResponseItems.nextPageToken = response.nextPageToken;\r\n    }\r\n    return freezeSys(mixinStringifySafe(toPlainObject(mappedResponseItems)));\r\n}\r\n/**\r\n * @private\r\n * @param items\r\n * @returns Entities mapped to an object for each entity type\r\n */\r\nfunction mapResponseItems(items) {\r\n    const reducer = (type) => {\r\n        return (accumulated, item) => {\r\n            if (item.sys.type === type) {\r\n                accumulated.push(toPlainObject(item));\r\n            }\r\n            return accumulated;\r\n        };\r\n    };\r\n    return {\r\n        entries: items.reduce(reducer('Entry'), []),\r\n        assets: items.reduce(reducer('Asset'), []),\r\n        deletedEntries: items.reduce(reducer('DeletedEntry'), []),\r\n        deletedAssets: items.reduce(reducer('DeletedAsset'), []),\r\n    };\r\n}\r\nfunction createRequestQuery(originalQuery) {\r\n    if (originalQuery.nextPageToken) {\r\n        return { sync_token: originalQuery.nextPageToken };\r\n    }\r\n    if (originalQuery.nextSyncToken) {\r\n        return { sync_token: originalQuery.nextSyncToken };\r\n    }\r\n    if (originalQuery.sync_token) {\r\n        return { sync_token: originalQuery.sync_token };\r\n    }\r\n    return originalQuery;\r\n}\r\n/**\r\n * If the response contains a nextPageUrl, extracts the sync token to get the\r\n * next page and calls itself again with that token.\r\n * Otherwise, if the response contains a nextSyncUrl, extracts the sync token\r\n * and returns it.\r\n * On each call of this function, any retrieved items are collected in the\r\n * supplied items array, which gets returned in the end.\r\n */\r\nasync function getSyncPage(http, items, query, { paginate }) {\r\n    const requestQuery = createRequestQuery(query);\r\n    const response = await http.get('sync', createRequestConfig({ query: requestQuery }));\r\n    const data = response.data || {};\r\n    items = items.concat(data.items || []);\r\n    if (data.nextPageUrl) {\r\n        if (paginate) {\r\n            delete requestQuery.initial;\r\n            requestQuery.sync_token = getToken(data.nextPageUrl);\r\n            return getSyncPage(http, items, requestQuery, { paginate });\r\n        }\r\n        return {\r\n            items,\r\n            nextPageToken: getToken(data.nextPageUrl),\r\n        };\r\n    }\r\n    else if (data.nextSyncUrl) {\r\n        return {\r\n            items,\r\n            nextSyncToken: getToken(data.nextSyncUrl),\r\n        };\r\n    }\r\n    else {\r\n        return { items: [] };\r\n    }\r\n}\r\n/**\r\n * Extracts token out of an url\r\n * @private\r\n */\r\nfunction getToken(url) {\r\n    const urlParts = url.split('?');\r\n    return urlParts.length > 0 ? urlParts[1].replace('sync_token=', '') : '';\r\n}\r\n\r\nexport { pagedSync as default };\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}